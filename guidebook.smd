% HOL Guidebook

Introduction
-------------

HOL stands for higher-order logic. HOL is also the name of the theorem prover.

I assume you are familiar with [functional programming][w:fp] and [higher-order logic][7].
(If you are not, don't worry, these topics will be introduced gently and are
easy to pick up.) The main point of this tutorial is to show you how to build
theories in the HOL theorem prover, assuming you have an idea of what you want
to formalise and how to prove your theorems mathematically.

If you have trouble with anything, there is plenty of community support
available including mailing lists and online chat. See the [HOL website][]
for details.

[HOL website]: https://hol-theorem-prover.org
[7]: http://www.cas.mcmaster.ca/sqrl/papers/SQRLreport18_rev2.pdf
[w:fp]: https://en.wikipedia.org/wiki/Functional_programming

Installation
-------------
Go to the [HOL website][].
Follow the instructions there to install HOL.

Alternatively, you can follow the first part of the
[CakeML build instructions](https://code.cakeml.org/tree/master/build-instructions.sh).

It is a good idea to set the environment variable `$HOLDIR` to point to the
location of your HOL installation. I will refer to this directory by `$HOLDIR`
from now on.

Running hol
------------
Now you can run `hol` at the command line. You will be greeted with a welcome
message, and prompted with a read-eval-print loop (REPL). This is in fact the
REPL for the underlying ML system.

HOL is just a library for theorem proving in Standard ML (abbreviated as ML).
Interacting with HOL, therefore, can be seen as programming in ML. If you don't
use any of the HOL-specific parts, you just have Standard ML:

     >> 3 + 4;

The HOL additions include new datatypes like `thm`, which represents a proven
theorem. Some values of this type are already in scope:

     >> SKOLEM_THM;

Script files
-------------
Usual practice is not to program directly at the REPL. Instead, you write a
_script file_ which can be processed by a tool called `Holmake` to build a
theory. A typical script file looks like this:

    open HolKernel boolLib bossLib Parse;

    val _ = new_theory"test";

    (* SML declarations  *)
    (* for example: *)
    val th = save_thm("SKOLEM_AGAIN",SKOLEM_THM);

    val _ = export_theory();

The script file above should be saved as `testScript.sml`, because the name passed to `new_theory` is `"test"`.
To produce a theory from this script file, run `Holmake` as follows:

    $ Holmake testTheory.uo

`Holmake` knows to look for `testScript.sml` when given the target `testTheory.uo`.
It will run the script and produce the following files as output:
`testTheory.sig`, `testTheory.sml`, `testTheory.ui`, and `testTheory.uo`.

The `testTheory.sig` file contains a summary of the contents of the generated
theory.  In this case, you will see that `testTheory` contains a single
theorem, which is just a copy of `SKOLEM_THM` saved under the name
`SKOLEM_AGAIN`.

The other generated files are the mechanism by which persistent theories are
implemented on disk, and can be ignored for now.

Interaction
------------
One would like to develop a script file with the same ease as programming at
the REPL. For this, there are plugins for two text editors, Vim and Emacs,
which enable script-file writing alongside an interactive HOL session. Both are
included in your HOL installation. The Vim plugin is documented at
`$HOLDIR/tools/vim/README` ([also here](https://github.com/HOL-Theorem-Prover/HOL/tree/master/tools/vim/README)).
The Emacs plugin is documented [online](https://hol-theorem-prover.org/hol-mode.html).

The idea behind these interaction plugins is to write a script file that will
eventually be suitable for processing by `Holmake`, but to see, step-by-step in
the REPL, what is happening at each point of the script file as you are writing
it.

As an example, let's try the Vim plugin on the `testScript.sml` file from
above. First, install the Vim plugin by following the instructions in its
`README`. Next, open `testScript.sml` in Vim, and also start `hol`. I usually
put these two windows (`hol` and `vim`) side by side, so I can see what is
happening in both at once.

We begin processing from the top of the file. Select the first line (the one
containing `open`). (To select a line in `vim`, position the cursor on the line
and press `V`.) Tell `hol` to load those theories and libraries by typing `hl`.
You should see some output like:

    HOLLoadSendQuiet HolKernel boolLib bossLib Parse completed

Next, move down to the line containing `save_thm` and send it to `hol` by
typing `hs`. You should see some output like:

    >>- val th = save_thm("SKOLEM_AGAIN",SKOLEM_THM);

You can, at this point, also write directly into the REPL if you want.
For example, to see that this theorem has no hypotheses, try:

    >> hyp th;

But of course, if you want to add anything to the theory you produce, you
should write it in the script file.

Types and Parsing
------------------
The syntax of higher-order logic includes types and terms. These are two of the
main datatypes implemented by HOL, over and above what is provided by ML. Here
is a type:

    >> bool;

In fact, `bool` is one of a handful of types that are bound to ML variables by
default. In general, you can make a type by providing the name of a type
operator and a list of arguments:

    >> mk_type("bool",[]);

    >> mk_type("list",[bool]); (* the type of a list of Booleans *)

But it is often more convenient to call the _type parser_ rather than `mk_type` directly.

    >> ``:num list``;

The backticks (\`) above are special syntax provided by HOL for calling the
type parser. The underlying parser function is called `Type`. We can call the
parser more directly:

    >> Type `:num list`;

The single backticks represent another special syntax, this time for a
_quotation_. Removing the special syntax entirely, we can write:

    >> Type [QUOTE":num list"];

Types can include variables. `alpha` is bound to a type variable, which can also be written as `:'a`.

    >> alpha; ``:'a``;

Quotations can include values that do not need to be parsed. For example:

    >> ``:^(mk_type("list",[alpha])) list``; (* list of lists of alphas *)

This is syntactic sugar for:

    >> Type [QUOTE":", ANTIQUOTE (mk_type("list",[alpha])), QUOTE " list"];

Theories
---------
Every type operator (like `list`) above is

Terms
------

Theorems
---------

Searching for theorems
-----------------------

Simple proofs
--------------

Useful tactics
---------------
